"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class van_calib_t(object):
    __slots__ = ["width", "height", "fc", "cc", "alpha_c", "fc_std", "cc_std", "alpha_c_std", "kc", "kc_std", "kc_model", "K", "Kinv", "fov"]

    KC_MODEL_RADIAL = 0
    KC_MODEL_RADTAN = 1
    KC_MODEL_SPHERICAL = 2
    KC_MODEL_FULL_MAP = 3

    def __init__(self):
        self.width = 0
        self.height = 0
        self.fc = [ 0.0 for dim0 in range(2) ]
        self.cc = [ 0.0 for dim0 in range(2) ]
        self.alpha_c = 0.0
        self.fc_std = [ 0.0 for dim0 in range(2) ]
        self.cc_std = [ 0.0 for dim0 in range(2) ]
        self.alpha_c_std = 0.0
        self.kc = [ 0.0 for dim0 in range(5) ]
        self.kc_std = [ 0.0 for dim0 in range(5) ]
        self.kc_model = 0
        self.K = [ 0.0 for dim0 in range(9) ]
        self.Kinv = [ 0.0 for dim0 in range(9) ]
        self.fov = [ 0.0 for dim0 in range(2) ]

    def encode(self):
        buf = BytesIO()
        buf.write(van_calib_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">ii", self.width, self.height))
        buf.write(struct.pack('>2d', *self.fc[:2]))
        buf.write(struct.pack('>2d', *self.cc[:2]))
        buf.write(struct.pack(">d", self.alpha_c))
        buf.write(struct.pack('>2d', *self.fc_std[:2]))
        buf.write(struct.pack('>2d', *self.cc_std[:2]))
        buf.write(struct.pack(">d", self.alpha_c_std))
        buf.write(struct.pack('>5d', *self.kc[:5]))
        buf.write(struct.pack('>5d', *self.kc_std[:5]))
        buf.write(struct.pack(">i", self.kc_model))
        buf.write(struct.pack('>9d', *self.K[:9]))
        buf.write(struct.pack('>9d', *self.Kinv[:9]))
        buf.write(struct.pack('>2d', *self.fov[:2]))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != van_calib_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return van_calib_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = van_calib_t()
        self.width, self.height = struct.unpack(">ii", buf.read(8))
        self.fc = struct.unpack('>2d', buf.read(16))
        self.cc = struct.unpack('>2d', buf.read(16))
        self.alpha_c = struct.unpack(">d", buf.read(8))[0]
        self.fc_std = struct.unpack('>2d', buf.read(16))
        self.cc_std = struct.unpack('>2d', buf.read(16))
        self.alpha_c_std = struct.unpack(">d", buf.read(8))[0]
        self.kc = struct.unpack('>5d', buf.read(40))
        self.kc_std = struct.unpack('>5d', buf.read(40))
        self.kc_model = struct.unpack(">i", buf.read(4))[0]
        self.K = struct.unpack('>9d', buf.read(72))
        self.Kinv = struct.unpack('>9d', buf.read(72))
        self.fov = struct.unpack('>2d', buf.read(16))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if van_calib_t in parents: return 0
        tmphash = (0x41bdf4eaf76fd2d2) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if van_calib_t._packed_fingerprint is None:
            van_calib_t._packed_fingerprint = struct.pack(">Q", van_calib_t._get_hash_recursive([]))
        return van_calib_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

