"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class ms_gx3_t(object):
    __slots__ = ["utime", "bitmask", "sMagField", "sAccel", "sAngRate", "sEuler", "sM", "sQ", "iMagField", "iAccel", "iAngRate", "Temperature", "TimerTicks", "MagGainScale", "AccelGainScale", "GyroGainScale"]

    INST_MAGFIELD = 1
    INST_ACCEL = 2
    INST_ANGRATE = 4
    STAB_MAGFIELD = 8
    STAB_ACCEL = 16
    STAB_ANGRATE = 32
    STAB_EULER = 64
    STAB_M = 128
    STAB_Q = 256
    TEMPERATURE = 512

    def __init__(self):
        self.utime = 0
        self.bitmask = 0
        self.sMagField = [ 0.0 for dim0 in range(3) ]
        self.sAccel = [ 0.0 for dim0 in range(3) ]
        self.sAngRate = [ 0.0 for dim0 in range(3) ]
        self.sEuler = [ 0.0 for dim0 in range(3) ]
        self.sM = [ [ 0.0 for dim1 in range(3) ] for dim0 in range(3) ]
        self.sQ = [ 0.0 for dim0 in range(4) ]
        self.iMagField = [ 0.0 for dim0 in range(3) ]
        self.iAccel = [ 0.0 for dim0 in range(3) ]
        self.iAngRate = [ 0.0 for dim0 in range(3) ]
        self.Temperature = 0.0
        self.TimerTicks = 0
        self.MagGainScale = 0
        self.AccelGainScale = 0
        self.GyroGainScale = 0

    def encode(self):
        buf = BytesIO()
        buf.write(ms_gx3_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qq", self.utime, self.bitmask))
        buf.write(struct.pack('>3d', *self.sMagField[:3]))
        buf.write(struct.pack('>3d', *self.sAccel[:3]))
        buf.write(struct.pack('>3d', *self.sAngRate[:3]))
        buf.write(struct.pack('>3d', *self.sEuler[:3]))
        for i0 in range(3):
            buf.write(struct.pack('>3d', *self.sM[i0][:3]))
        buf.write(struct.pack('>4d', *self.sQ[:4]))
        buf.write(struct.pack('>3d', *self.iMagField[:3]))
        buf.write(struct.pack('>3d', *self.iAccel[:3]))
        buf.write(struct.pack('>3d', *self.iAngRate[:3]))
        buf.write(struct.pack(">dihhh", self.Temperature, self.TimerTicks, self.MagGainScale, self.AccelGainScale, self.GyroGainScale))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != ms_gx3_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return ms_gx3_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = ms_gx3_t()
        self.utime, self.bitmask = struct.unpack(">qq", buf.read(16))
        self.sMagField = struct.unpack('>3d', buf.read(24))
        self.sAccel = struct.unpack('>3d', buf.read(24))
        self.sAngRate = struct.unpack('>3d', buf.read(24))
        self.sEuler = struct.unpack('>3d', buf.read(24))
        self.sM = []
        for i0 in range(3):
            self.sM.append(struct.unpack('>3d', buf.read(24)))
        self.sQ = struct.unpack('>4d', buf.read(32))
        self.iMagField = struct.unpack('>3d', buf.read(24))
        self.iAccel = struct.unpack('>3d', buf.read(24))
        self.iAngRate = struct.unpack('>3d', buf.read(24))
        self.Temperature, self.TimerTicks, self.MagGainScale, self.AccelGainScale, self.GyroGainScale = struct.unpack(">dihhh", buf.read(18))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if ms_gx3_t in parents: return 0
        tmphash = (0xbd61abbb1db6d0ad) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if ms_gx3_t._packed_fingerprint is None:
            ms_gx3_t._packed_fingerprint = struct.pack(">Q", ms_gx3_t._get_hash_recursive([]))
        return ms_gx3_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

