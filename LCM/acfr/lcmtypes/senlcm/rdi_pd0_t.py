"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class rdi_pd0_t(object):
    __slots__ = ["utime", "cpu_fw_ver", "cpu_fw_rev", "system_config", "sim_flag", "num_beams", "num_cells", "pings_per_ens", "depth_cell_length", "blank_after_xmit", "profiling_mode", "low_corr_threshold", "num_code_reps", "gd_min", "err_vel_max", "tpp_mins", "tpp_secs", "tpp_hund", "coord_trans", "heading_align", "heading_bias", "sensor_source", "sensors_avail", "bin1_dist", "xmit_pulse_len", "wp_ref_avg", "false_target", "xmit_lag_dist", "cpu_serial", "sys_bw", "ens_num", "rtc_year", "rtc_month", "rtc_day", "rtc_hour", "rtc_min", "rtc_sec", "rtc_hund", "ens_msb", "bit_result", "sos", "depth", "heading", "pitch", "roll", "salinity", "temp", "mpt_min", "mpt_sec", "mpt_hund", "head_std", "pitch_std", "roll_std", "adc", "error", "pressure", "press_var", "num_velocities", "velocity"]

    def __init__(self):
        self.utime = 0
        self.cpu_fw_ver = 0
        self.cpu_fw_rev = 0
        self.system_config = 0
        self.sim_flag = 0
        self.num_beams = 0
        self.num_cells = 0
        self.pings_per_ens = 0
        self.depth_cell_length = 0.0
        self.blank_after_xmit = 0.0
        self.profiling_mode = 0
        self.low_corr_threshold = 0
        self.num_code_reps = 0
        self.gd_min = 0
        self.err_vel_max = 0.0
        self.tpp_mins = 0
        self.tpp_secs = 0
        self.tpp_hund = 0
        self.coord_trans = 0
        self.heading_align = 0.0
        self.heading_bias = 0.0
        self.sensor_source = 0
        self.sensors_avail = 0
        self.bin1_dist = 0.0
        self.xmit_pulse_len = 0.0
        self.wp_ref_avg = 0
        self.false_target = 0
        self.xmit_lag_dist = 0.0
        self.cpu_serial = 0
        self.sys_bw = 0
        self.ens_num = 0
        self.rtc_year = 0
        self.rtc_month = 0
        self.rtc_day = 0
        self.rtc_hour = 0
        self.rtc_min = 0
        self.rtc_sec = 0
        self.rtc_hund = 0
        self.ens_msb = 0
        self.bit_result = 0
        self.sos = 0
        self.depth = 0.0
        self.heading = 0.0
        self.pitch = 0.0
        self.roll = 0.0
        self.salinity = 0
        self.temp = 0.0
        self.mpt_min = 0
        self.mpt_sec = 0
        self.mpt_hund = 0
        self.head_std = 0
        self.pitch_std = 0.0
        self.roll_std = 0.0
        self.adc = ""
        self.error = 0
        self.pressure = 0.0
        self.press_var = 0.0
        self.num_velocities = 0
        self.velocity = []

    def encode(self):
        buf = BytesIO()
        buf.write(rdi_pd0_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qBBhBBBhddBBBBdBBBBddBBddhBdhhhBBBBBBBBhhddddhdBBBBdd", self.utime, self.cpu_fw_ver, self.cpu_fw_rev, self.system_config, self.sim_flag, self.num_beams, self.num_cells, self.pings_per_ens, self.depth_cell_length, self.blank_after_xmit, self.profiling_mode, self.low_corr_threshold, self.num_code_reps, self.gd_min, self.err_vel_max, self.tpp_mins, self.tpp_secs, self.tpp_hund, self.coord_trans, self.heading_align, self.heading_bias, self.sensor_source, self.sensors_avail, self.bin1_dist, self.xmit_pulse_len, self.wp_ref_avg, self.false_target, self.xmit_lag_dist, self.cpu_serial, self.sys_bw, self.ens_num, self.rtc_year, self.rtc_month, self.rtc_day, self.rtc_hour, self.rtc_min, self.rtc_sec, self.rtc_hund, self.ens_msb, self.bit_result, self.sos, self.depth, self.heading, self.pitch, self.roll, self.salinity, self.temp, self.mpt_min, self.mpt_sec, self.mpt_hund, self.head_std, self.pitch_std, self.roll_std))
        buf.write(bytearray(self.adc[:8]))
        buf.write(struct.pack(">iddh", self.error, self.pressure, self.press_var, self.num_velocities))
        buf.write(struct.pack('>%dd' % self.num_velocities, *self.velocity[:self.num_velocities]))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != rdi_pd0_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return rdi_pd0_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = rdi_pd0_t()
        self.utime, self.cpu_fw_ver, self.cpu_fw_rev, self.system_config, self.sim_flag, self.num_beams, self.num_cells, self.pings_per_ens, self.depth_cell_length, self.blank_after_xmit, self.profiling_mode, self.low_corr_threshold, self.num_code_reps, self.gd_min, self.err_vel_max, self.tpp_mins, self.tpp_secs, self.tpp_hund, self.coord_trans, self.heading_align, self.heading_bias, self.sensor_source, self.sensors_avail, self.bin1_dist, self.xmit_pulse_len, self.wp_ref_avg, self.false_target, self.xmit_lag_dist, self.cpu_serial, self.sys_bw, self.ens_num, self.rtc_year, self.rtc_month, self.rtc_day, self.rtc_hour, self.rtc_min, self.rtc_sec, self.rtc_hund, self.ens_msb, self.bit_result, self.sos, self.depth, self.heading, self.pitch, self.roll, self.salinity, self.temp, self.mpt_min, self.mpt_sec, self.mpt_hund, self.head_std, self.pitch_std, self.roll_std = struct.unpack(">qBBhBBBhddBBBBdBBBBddBBddhBdhhhBBBBBBBBhhddddhdBBBBdd", buf.read(174))
        self.adc = buf.read(8)
        self.error, self.pressure, self.press_var, self.num_velocities = struct.unpack(">iddh", buf.read(22))
        self.velocity = struct.unpack('>%dd' % self.num_velocities, buf.read(self.num_velocities * 8))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if rdi_pd0_t in parents: return 0
        tmphash = (0xbd85b46ad19215e7) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if rdi_pd0_t._packed_fingerprint is None:
            rdi_pd0_t._packed_fingerprint = struct.pack(">Q", rdi_pd0_t._get_hash_recursive([]))
        return rdi_pd0_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

