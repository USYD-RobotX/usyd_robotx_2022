"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class ms_gx1_t(object):
    __slots__ = ["utime", "bitmask", "sMagField", "sAccel", "sAngRate", "sEuler", "sM", "sQ", "iMagField", "iAccel", "iAngRate", "iEuler", "iM", "iQ", "Temperature", "TimerTicks", "MagGainScale", "AccelGainScale", "GyroGainScale"]

    INST_MAGFIELD = 1
    INST_ACCEL = 2
    INST_ANGRATE = 4
    INST_EULER = 8
    INST_M = 16
    INST_Q = 32
    STAB_MAGFIELD = 64
    STAB_ACCEL = 128
    STAB_ANGRATE = 256
    STAB_EULER = 512
    STAB_M = 1024
    STAB_Q = 2048
    TEMPERATURE = 4096

    def __init__(self):
        self.utime = 0
        self.bitmask = 0
        self.sMagField = [ 0.0 for dim0 in range(3) ]
        self.sAccel = [ 0.0 for dim0 in range(3) ]
        self.sAngRate = [ 0.0 for dim0 in range(3) ]
        self.sEuler = [ 0.0 for dim0 in range(3) ]
        self.sM = [ [ 0.0 for dim1 in range(3) ] for dim0 in range(3) ]
        self.sQ = [ 0.0 for dim0 in range(4) ]
        self.iMagField = [ 0.0 for dim0 in range(3) ]
        self.iAccel = [ 0.0 for dim0 in range(3) ]
        self.iAngRate = [ 0.0 for dim0 in range(3) ]
        self.iEuler = [ 0.0 for dim0 in range(3) ]
        self.iM = [ [ 0.0 for dim1 in range(3) ] for dim0 in range(3) ]
        self.iQ = [ 0.0 for dim0 in range(4) ]
        self.Temperature = 0.0
        self.TimerTicks = 0
        self.MagGainScale = 0
        self.AccelGainScale = 0
        self.GyroGainScale = 0

    def encode(self):
        buf = BytesIO()
        buf.write(ms_gx1_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qq", self.utime, self.bitmask))
        buf.write(struct.pack('>3d', *self.sMagField[:3]))
        buf.write(struct.pack('>3d', *self.sAccel[:3]))
        buf.write(struct.pack('>3d', *self.sAngRate[:3]))
        buf.write(struct.pack('>3d', *self.sEuler[:3]))
        for i0 in range(3):
            buf.write(struct.pack('>3d', *self.sM[i0][:3]))
        buf.write(struct.pack('>4d', *self.sQ[:4]))
        buf.write(struct.pack('>3d', *self.iMagField[:3]))
        buf.write(struct.pack('>3d', *self.iAccel[:3]))
        buf.write(struct.pack('>3d', *self.iAngRate[:3]))
        buf.write(struct.pack('>3d', *self.iEuler[:3]))
        for i0 in range(3):
            buf.write(struct.pack('>3d', *self.iM[i0][:3]))
        buf.write(struct.pack('>4d', *self.iQ[:4]))
        buf.write(struct.pack(">dhhhh", self.Temperature, self.TimerTicks, self.MagGainScale, self.AccelGainScale, self.GyroGainScale))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != ms_gx1_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return ms_gx1_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = ms_gx1_t()
        self.utime, self.bitmask = struct.unpack(">qq", buf.read(16))
        self.sMagField = struct.unpack('>3d', buf.read(24))
        self.sAccel = struct.unpack('>3d', buf.read(24))
        self.sAngRate = struct.unpack('>3d', buf.read(24))
        self.sEuler = struct.unpack('>3d', buf.read(24))
        self.sM = []
        for i0 in range(3):
            self.sM.append(struct.unpack('>3d', buf.read(24)))
        self.sQ = struct.unpack('>4d', buf.read(32))
        self.iMagField = struct.unpack('>3d', buf.read(24))
        self.iAccel = struct.unpack('>3d', buf.read(24))
        self.iAngRate = struct.unpack('>3d', buf.read(24))
        self.iEuler = struct.unpack('>3d', buf.read(24))
        self.iM = []
        for i0 in range(3):
            self.iM.append(struct.unpack('>3d', buf.read(24)))
        self.iQ = struct.unpack('>4d', buf.read(32))
        self.Temperature, self.TimerTicks, self.MagGainScale, self.AccelGainScale, self.GyroGainScale = struct.unpack(">dhhhh", buf.read(16))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if ms_gx1_t in parents: return 0
        tmphash = (0xf2d3986782261f29) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if ms_gx1_t._packed_fingerprint is None:
            ms_gx1_t._packed_fingerprint = struct.pack(">Q", ms_gx1_t._get_hash_recursive([]))
        return ms_gx1_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

