"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class subsonus_remote_track_t(object):
    __slots__ = ["utime", "remote_address", "tracking_status", "local_system_status", "local_filter_status", "data_valid_flags", "local_unix_seconds", "local_microseconds", "local_latitude", "local_longitude", "local_height", "velocity_ned", "rpy", "local_llh_sigma", "local_rpy_sigma", "local_depth", "remote_age_usec", "remote_range", "remote_azimuth", "remote_elevation", "xyz", "xyz_level", "target_ned", "remote_latitude", "remote_longitude", "remote_height", "remote_rae_sigma", "remote_llh_sigma", "remote_depth", "signal_level", "snr", "scr", "sci"]

    def __init__(self):
        self.utime = 0
        self.remote_address = 0
        self.tracking_status = 0
        self.local_system_status = 0
        self.local_filter_status = 0
        self.data_valid_flags = 0
        self.local_unix_seconds = 0
        self.local_microseconds = 0
        self.local_latitude = 0.0
        self.local_longitude = 0.0
        self.local_height = 0.0
        self.velocity_ned = [ 0.0 for dim0 in range(3) ]
        self.rpy = [ 0.0 for dim0 in range(3) ]
        self.local_llh_sigma = [ 0.0 for dim0 in range(3) ]
        self.local_rpy_sigma = [ 0.0 for dim0 in range(3) ]
        self.local_depth = 0.0
        self.remote_age_usec = 0
        self.remote_range = 0.0
        self.remote_azimuth = 0.0
        self.remote_elevation = 0.0
        self.xyz = [ 0.0 for dim0 in range(3) ]
        self.xyz_level = [ 0.0 for dim0 in range(3) ]
        self.target_ned = [ 0.0 for dim0 in range(3) ]
        self.remote_latitude = 0.0
        self.remote_longitude = 0.0
        self.remote_height = 0.0
        self.remote_rae_sigma = [ 0.0 for dim0 in range(3) ]
        self.remote_llh_sigma = [ 0.0 for dim0 in range(3) ]
        self.remote_depth = 0.0
        self.signal_level = 0
        self.snr = 0
        self.scr = 0
        self.sci = 0

    def encode(self):
        buf = BytesIO()
        buf.write(subsonus_remote_track_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qhbiiiiiddd", self.utime, self.remote_address, self.tracking_status, self.local_system_status, self.local_filter_status, self.data_valid_flags, self.local_unix_seconds, self.local_microseconds, self.local_latitude, self.local_longitude, self.local_height))
        buf.write(struct.pack('>3f', *self.velocity_ned[:3]))
        buf.write(struct.pack('>3f', *self.rpy[:3]))
        buf.write(struct.pack('>3f', *self.local_llh_sigma[:3]))
        buf.write(struct.pack('>3f', *self.local_rpy_sigma[:3]))
        buf.write(struct.pack(">fifff", self.local_depth, self.remote_age_usec, self.remote_range, self.remote_azimuth, self.remote_elevation))
        buf.write(struct.pack('>3f', *self.xyz[:3]))
        buf.write(struct.pack('>3f', *self.xyz_level[:3]))
        buf.write(struct.pack('>3f', *self.target_ned[:3]))
        buf.write(struct.pack(">ddd", self.remote_latitude, self.remote_longitude, self.remote_height))
        buf.write(struct.pack('>3f', *self.remote_rae_sigma[:3]))
        buf.write(struct.pack('>3f', *self.remote_llh_sigma[:3]))
        buf.write(struct.pack(">fbbbb", self.remote_depth, self.signal_level, self.snr, self.scr, self.sci))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != subsonus_remote_track_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return subsonus_remote_track_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = subsonus_remote_track_t()
        self.utime, self.remote_address, self.tracking_status, self.local_system_status, self.local_filter_status, self.data_valid_flags, self.local_unix_seconds, self.local_microseconds, self.local_latitude, self.local_longitude, self.local_height = struct.unpack(">qhbiiiiiddd", buf.read(55))
        self.velocity_ned = struct.unpack('>3f', buf.read(12))
        self.rpy = struct.unpack('>3f', buf.read(12))
        self.local_llh_sigma = struct.unpack('>3f', buf.read(12))
        self.local_rpy_sigma = struct.unpack('>3f', buf.read(12))
        self.local_depth, self.remote_age_usec, self.remote_range, self.remote_azimuth, self.remote_elevation = struct.unpack(">fifff", buf.read(20))
        self.xyz = struct.unpack('>3f', buf.read(12))
        self.xyz_level = struct.unpack('>3f', buf.read(12))
        self.target_ned = struct.unpack('>3f', buf.read(12))
        self.remote_latitude, self.remote_longitude, self.remote_height = struct.unpack(">ddd", buf.read(24))
        self.remote_rae_sigma = struct.unpack('>3f', buf.read(12))
        self.remote_llh_sigma = struct.unpack('>3f', buf.read(12))
        self.remote_depth, self.signal_level, self.snr, self.scr, self.sci = struct.unpack(">fbbbb", buf.read(8))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if subsonus_remote_track_t in parents: return 0
        tmphash = (0xda85a2794dd0579a) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if subsonus_remote_track_t._packed_fingerprint is None:
            subsonus_remote_track_t._packed_fingerprint = struct.pack(">Q", subsonus_remote_track_t._get_hash_recursive([]))
        return subsonus_remote_track_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

