"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class pelican_t(object):
    __slots__ = ["utime", "battery_voltage", "status", "cpu_load", "compass_enabled", "chksum_error", "flying", "motors_on", "flightMode", "up_time", "angle", "angvel", "acc_calib", "acc", "acc_angle", "acc_absolute_value", "magField", "mag_heading", "speed", "heightImu", "dheight", "dheight_reference", "height_reference", "latitude", "longitude", "heightGps", "speedGps", "heading", "horizontal_accuracy", "vertical_accuracy", "speed_accuracy", "numSV", "statusGps", "rcData", "lock", "nick", "roll", "yaw", "thrust"]

    PD_IMURAWDATA = 1
    PD_LLSTATUS = 2
    PD_IMUCALCDATA = 3
    PD_HLSTATUS = 4
    PD_DEBUGDATA = 5
    PD_CTRLOUT = 17
    PD_FLIGHTPARAMS = 18
    PD_CTRLCOMMANDS = 19
    PD_CTRLINTERNAL = 20
    PD_RCDATA = 21
    PD_CTRLSTATUS = 22
    PD_CTRLINPUT = 23
    PD_CTRLFALCON = 24
    PD_WAYPOINT = 32
    PD_CURRENTWAY = 33
    PD_NMEADATA = 34
    PD_GPSDATA = 35
    PD_SINGLEWAYPOINT = 36
    PD_GOTOCOMMAND = 37
    PD_LAUNCHCOMMAND = 38
    PD_LANDCOMMAND = 39
    PD_HOMECOMMAND = 40
    PD_GPSDATAADVANCED = 41
    LL_STATUS_CMD = 1
    IMU_RAWDATA_CMD = 2
    IMU_CALCDATA_CMD = 4
    RC_DATA_CMD = 8
    CTRL_OUT_CMD = 16
    GPS_DATA_CMD = 128
    CURRENT_WAY_CMD = 256
    GPS_DATA_ADVANCED_CMD = 512
    CAM_DATA_CMD = 2048

    def __init__(self):
        self.utime = 0
        self.battery_voltage = 0.0
        self.status = 0
        self.cpu_load = 0
        self.compass_enabled = False
        self.chksum_error = False
        self.flying = False
        self.motors_on = False
        self.flightMode = 0
        self.up_time = 0
        self.angle = [ 0.0 for dim0 in range(3) ]
        self.angvel = [ 0 for dim0 in range(3) ]
        self.acc_calib = [ 0.0 for dim0 in range(3) ]
        self.acc = [ 0.0 for dim0 in range(3) ]
        self.acc_angle = [ 0.0 for dim0 in range(2) ]
        self.acc_absolute_value = 0.0
        self.magField = [ 0 for dim0 in range(3) ]
        self.mag_heading = 0.0
        self.speed = [ 0 for dim0 in range(3) ]
        self.heightImu = 0.0
        self.dheight = 0.0
        self.dheight_reference = 0.0
        self.height_reference = 0.0
        self.latitude = 0.0
        self.longitude = 0.0
        self.heightGps = 0.0
        self.speedGps = [ 0.0 for dim0 in range(2) ]
        self.heading = 0.0
        self.horizontal_accuracy = 0.0
        self.vertical_accuracy = 0.0
        self.speed_accuracy = 0.0
        self.numSV = 0
        self.statusGps = 0
        self.rcData = [ 0 for dim0 in range(8) ]
        self.lock = False
        self.nick = 0
        self.roll = 0
        self.yaw = 0
        self.thrust = 0

    def encode(self):
        buf = BytesIO()
        buf.write(pelican_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qdhhbbbbhh", self.utime, self.battery_voltage, self.status, self.cpu_load, self.compass_enabled, self.chksum_error, self.flying, self.motors_on, self.flightMode, self.up_time))
        buf.write(struct.pack('>3d', *self.angle[:3]))
        buf.write(struct.pack('>3i', *self.angvel[:3]))
        buf.write(struct.pack('>3d', *self.acc_calib[:3]))
        buf.write(struct.pack('>3d', *self.acc[:3]))
        buf.write(struct.pack('>2d', *self.acc_angle[:2]))
        buf.write(struct.pack(">d", self.acc_absolute_value))
        buf.write(struct.pack('>3i', *self.magField[:3]))
        buf.write(struct.pack(">d", self.mag_heading))
        buf.write(struct.pack('>3i', *self.speed[:3]))
        buf.write(struct.pack(">ddddddd", self.heightImu, self.dheight, self.dheight_reference, self.height_reference, self.latitude, self.longitude, self.heightGps))
        buf.write(struct.pack('>2d', *self.speedGps[:2]))
        buf.write(struct.pack(">ddddii", self.heading, self.horizontal_accuracy, self.vertical_accuracy, self.speed_accuracy, self.numSV, self.statusGps))
        buf.write(struct.pack('>8h', *self.rcData[:8]))
        buf.write(struct.pack(">biiii", self.lock, self.nick, self.roll, self.yaw, self.thrust))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != pelican_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return pelican_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = pelican_t()
        self.utime, self.battery_voltage, self.status, self.cpu_load = struct.unpack(">qdhh", buf.read(20))
        self.compass_enabled = bool(struct.unpack('b', buf.read(1))[0])
        self.chksum_error = bool(struct.unpack('b', buf.read(1))[0])
        self.flying = bool(struct.unpack('b', buf.read(1))[0])
        self.motors_on = bool(struct.unpack('b', buf.read(1))[0])
        self.flightMode, self.up_time = struct.unpack(">hh", buf.read(4))
        self.angle = struct.unpack('>3d', buf.read(24))
        self.angvel = struct.unpack('>3i', buf.read(12))
        self.acc_calib = struct.unpack('>3d', buf.read(24))
        self.acc = struct.unpack('>3d', buf.read(24))
        self.acc_angle = struct.unpack('>2d', buf.read(16))
        self.acc_absolute_value = struct.unpack(">d", buf.read(8))[0]
        self.magField = struct.unpack('>3i', buf.read(12))
        self.mag_heading = struct.unpack(">d", buf.read(8))[0]
        self.speed = struct.unpack('>3i', buf.read(12))
        self.heightImu, self.dheight, self.dheight_reference, self.height_reference, self.latitude, self.longitude, self.heightGps = struct.unpack(">ddddddd", buf.read(56))
        self.speedGps = struct.unpack('>2d', buf.read(16))
        self.heading, self.horizontal_accuracy, self.vertical_accuracy, self.speed_accuracy, self.numSV, self.statusGps = struct.unpack(">ddddii", buf.read(40))
        self.rcData = struct.unpack('>8h', buf.read(16))
        self.lock = bool(struct.unpack('b', buf.read(1))[0])
        self.nick, self.roll, self.yaw, self.thrust = struct.unpack(">iiii", buf.read(16))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if pelican_t in parents: return 0
        tmphash = (0x1213c2b545cbfef) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if pelican_t._packed_fingerprint is None:
            pelican_t._packed_fingerprint = struct.pack(">Q", pelican_t._get_hash_recursive([]))
        return pelican_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

