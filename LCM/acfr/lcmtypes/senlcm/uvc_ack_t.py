"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class uvc_ack_t(object):
    __slots__ = ["utime", "msg_type", "status", "err_num", "usrset", "usrnum", "usrval"]

    ACK_OMSTOP = 1
    ACK_OMLOAD = 2
    ACK_OMSTART = 3
    ACK_OLOGD = 4
    ACK_OLOGL = 5
    ACK_OPOS = 6
    ACK_OJW = 7
    ACK_OSD = 8
    ACK_OMS = 9
    ACK_OMP = 10
    ACK_OPK = 11
    ACK_ORWSET = 12
    ACK_SRP = 13
    ACK_SENS_MALFUNCTION = 14
    ACK_ODVL = 15
    ACK_OMW = 16
    ACK_OFILE = 17
    ACK_NO_ERROR = 0
    ACK_ERROR = 1
    ACK_ERR_OMSTART_FILE_NOT_FOUND = 1
    ACK_ERR_OMSTART_DIR_NOT_FOUND = 2
    ACK_ERR_OMSTART_ERR_LOADING_MISSION = 3
    ACK_ERR_SONAR_COM_CONF_UVC = 4
    ACK_ERR_SONAR_COM_CONF_SONAR_CONTROL = 5
    ACK_ERR_UVC_COM_CONF_SONAR_CONTROL = 6
    ACK_ERR_INI_FILE_NOT_FOUND_SONAR_CONTROL = 7
    ACK_ERR_LOADING_INI_SONAR_CONTROL = 8
    ACK_ERR_VIDEO_COM_CONF_UVC = 9
    ACK_ERR_UVC_COM_CONF_VIDEO_CONTROL = 10
    ACK_ERR_INI_FILE_NOT_FOUND_VIDEO_CONTROL = 11
    ACK_ERR_LOADING_INI_VIDEO_CONTROL = 12
    ACK_ERR_MANDATORY_COM_CONF_UVC = 13
    ACK_ERR_COMPASS_DATA_AGE = 14
    ACK_ERR_GPS_DATA_AGE = 15
    ACK_ERR_SOUNDER_DATA_AGE = 16
    ACK_ERR_STARTING_MISSION = 17
    ACK_ERR_OPOS_INCORRECT_VALS = 18
    ACK_ERR_OJW_INCORRECT_VALS = 19
    ACK_ERR_OMS_INCORRECT_VALS = 20
    ACK_ERR_OMP_INCORRECT_VALS = 21
    ACK_ERR_OPK_INCORRECT_VALS = 22
    ACK_ERR_ORWSET_INCORRECT_VALS = 23
    ACK_ERR_OLOGL_INCORRECT_VALS = 24
    ACK_ERR_OLOGD_INCORRECT_VALS = 25
    ACK_ERR_SAFETY_RULE_ENGAGED_CMD_NOT_PROCESSED = 26
    ACK_ERR_OSD_INCORRECT_VALS = 27
    ACK_ERR_OMSTOP_INCORRECT_VALS = 28
    ACK_ERR_OMLOAD_INCORRECT_VALS = 29
    ACK_ERR_OMSTART_INCORRECT_VALS = 30
    ACK_ERR_OMSTART_SRP_FILE_NOT_FOUND_OR_BAD_FILE = 31
    ACK_ERR_PRESSURE_MALFUNCTION = 32
    ACK_ERR_CAMERA_MALFUNCTION_VIDEO_CONTROL = 33
    ACK_ERR_COMPASS_PARAM_INCORRECT = 34
    ACK_ERR_ODVL_INCORRECT_VALS = 35
    ACK_ERR_OMW_INCORRECT_VALS = 36
    ACK_ERR_DELTAT_COM_CONF_UVC = 37
    ACK_ERR_DELTAT_COM_CONF_DELTAT_CONTROL = 38
    ACK_ERR_OPK_NOT_ENOUGH_POWER = 39
    ACK_ERR_OPK_DISTANCE_GT_10_MI = 40
    ACK_ERR_OFILE_INCORRECT_VALS = 41
    ACK_ERR_OFILE_NO_FILES_INSIDE_GROUP = 42
    ACK_ERR_SONAR_CONTROL_CANNOT_COMMUNICATE_WITH_SONAR = 43
    ACK_ERR_SAFETY_TOWFLOAT_COM_CONF_UVC = 44
    ACK_ERR_IVER2_MUST_BE_RUNNING = 45
    ACK_ERR_MULTIBEAM_COM_CONF_MULTIBEAM_CONTROL = 46
    ACK_ERR_UVC_COM_CONF_MULTIBEAM_CONTROL = 47
    ACK_ERR_INI_FILE_NOT_FOUND_MULTIBEAM_CONTROL = 48
    ACK_ERR_LOADING_INI_FILE_MULTIBEAM_CONTROL = 49
    ACK_ERR_MULTIBEAM_CONTROL_CANNOT_COMMUNICATE_WITH_SONAR = 50
    ACK_ERR_WRONG_SIDESCAN_TYPE = 51
    ACK_ERR_WRONG_MULTIBEAM_TYPE = 52
    ACK_ERR_WRONG_CAMERA_TYPE = 53

    def __init__(self):
        self.utime = 0
        self.msg_type = 0
        self.status = 0
        self.err_num = 0
        self.usrset = ""
        self.usrnum = 0
        self.usrval = ""

    def encode(self):
        buf = BytesIO()
        buf.write(uvc_ack_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qiii", self.utime, self.msg_type, self.status, self.err_num))
        __usrset_encoded = self.usrset.encode('utf-8')
        buf.write(struct.pack('>I', len(__usrset_encoded)+1))
        buf.write(__usrset_encoded)
        buf.write(b"\0")
        buf.write(struct.pack(">i", self.usrnum))
        __usrval_encoded = self.usrval.encode('utf-8')
        buf.write(struct.pack('>I', len(__usrval_encoded)+1))
        buf.write(__usrval_encoded)
        buf.write(b"\0")

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != uvc_ack_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return uvc_ack_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = uvc_ack_t()
        self.utime, self.msg_type, self.status, self.err_num = struct.unpack(">qiii", buf.read(20))
        __usrset_len = struct.unpack('>I', buf.read(4))[0]
        self.usrset = buf.read(__usrset_len)[:-1].decode('utf-8', 'replace')
        self.usrnum = struct.unpack(">i", buf.read(4))[0]
        __usrval_len = struct.unpack('>I', buf.read(4))[0]
        self.usrval = buf.read(__usrval_len)[:-1].decode('utf-8', 'replace')
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if uvc_ack_t in parents: return 0
        tmphash = (0x76dbafc72d01cf6f) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if uvc_ack_t._packed_fingerprint is None:
            uvc_ack_t._packed_fingerprint = struct.pack(">Q", uvc_ack_t._get_hash_recursive([]))
        return uvc_ack_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

