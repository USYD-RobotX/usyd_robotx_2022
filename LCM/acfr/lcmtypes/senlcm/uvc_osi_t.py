"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class uvc_osi_t(object):
    __slots__ = ["utime", "yaw_top", "yaw_bot", "pitch_left", "pitch_right", "motor", "mode", "nextwp", "latitude", "longitude", "speed", "dist_to_nextwp", "error", "altimeter", "park_time", "magnetic_dec", "mission_name", "mission_time_remaining"]

    MODE_NORMAL = 1
    MODE_STOPPED = 2
    MODE_PARK = 3
    MODE_MANUAL_PARK = 4
    MODE_MANUAL_OVERRIDE = 5
    MODE_SERVO = 6
    MODE_MISSION = 7
    ERR_NONE = 0
    ERR_OVER_PITCH = 1
    ERR_EXCEED_TIME = 2
    ERR_LEAK = 3
    ERR_NO_FORWARD_PROG = 4
    ERR_EXCEED_MAX_DEPTH = 5
    ERR_NO_UPWARD_PROG = 6
    ERR_TOW_FLOAT_ENGAGED = 7
    ERR_SAFETY_RET_PATH = 8
    ERR_DFS_UNCHANGED = 9
    ERR_COMPASS_STOPPED = 10
    ERR_EXCEEDED_MIN_REQ_PWR = 11
    ERR_STOP_AND_TRANSMIT_IRIDIUM = 12

    def __init__(self):
        self.utime = 0
        self.yaw_top = 0
        self.yaw_bot = 0
        self.pitch_left = 0
        self.pitch_right = 0
        self.motor = 0
        self.mode = 0
        self.nextwp = 0
        self.latitude = 0.0
        self.longitude = 0.0
        self.speed = 0.0
        self.dist_to_nextwp = 0.0
        self.error = 0
        self.altimeter = 0.0
        self.park_time = 0
        self.magnetic_dec = 0.0
        self.mission_name = ""
        self.mission_time_remaining = 0.0

    def encode(self):
        buf = BytesIO()
        buf.write(uvc_osi_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qiiiiiiiddddidid", self.utime, self.yaw_top, self.yaw_bot, self.pitch_left, self.pitch_right, self.motor, self.mode, self.nextwp, self.latitude, self.longitude, self.speed, self.dist_to_nextwp, self.error, self.altimeter, self.park_time, self.magnetic_dec))
        __mission_name_encoded = self.mission_name.encode('utf-8')
        buf.write(struct.pack('>I', len(__mission_name_encoded)+1))
        buf.write(__mission_name_encoded)
        buf.write(b"\0")
        buf.write(struct.pack(">d", self.mission_time_remaining))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != uvc_osi_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return uvc_osi_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = uvc_osi_t()
        self.utime, self.yaw_top, self.yaw_bot, self.pitch_left, self.pitch_right, self.motor, self.mode, self.nextwp, self.latitude, self.longitude, self.speed, self.dist_to_nextwp, self.error, self.altimeter, self.park_time, self.magnetic_dec = struct.unpack(">qiiiiiiiddddidid", buf.read(92))
        __mission_name_len = struct.unpack('>I', buf.read(4))[0]
        self.mission_name = buf.read(__mission_name_len)[:-1].decode('utf-8', 'replace')
        self.mission_time_remaining = struct.unpack(">d", buf.read(8))[0]
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if uvc_osi_t in parents: return 0
        tmphash = (0xbb83a47bcb6e10db) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if uvc_osi_t._packed_fingerprint is None:
            uvc_osi_t._packed_fingerprint = struct.pack(">Q", uvc_osi_t._get_hash_recursive([]))
        return uvc_osi_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

